import os
import zipfile

# Define project structure and files
project_dir = "/mnt/data/zock_dashboard"
os.makedirs(project_dir, exist_ok=True)
os.makedirs(os.path.join(project_dir, "templates"), exist_ok=True)

files_content = {
    "sample_logs.jsonl": """{"ts":"2025-08-19T11:59:00Z","src_ip":"198.51.100.14","user":"bob","msg":"failed password for bob","service":"ssh"}
{"ts":"2025-08-19T11:59:10Z","src_ip":"198.51.100.14","user":"bob","msg":"failed password for bob","service":"ssh"}
{"ts":"2025-08-19T12:00:01Z","src_ip":"198.51.100.120","msg":"GET /admin HTTP/1.1 200 - unauthenticated","service":"httpd"}
{"ts":"2025-08-19T12:00:20Z","src_ip":"203.0.113.5","msg":"GET /index.php?q=1' UNION SELECT username,password FROM users --","service":"httpd"}
{"ts":"2025-08-19T12:01:00Z","src_ip":"203.0.113.5","msg":"GET /../../../etc/passwd HTTP/1.1 404","service":"httpd"}
{"ts":"2025-08-19T12:05:00Z","src_ip":"10.0.0.7","user":"alice","msg":"successful login","service":"ssh"}""",

    "ingest.py": """import json
from dateutil import parser

def read_jsonl(path):
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                obj = json.loads(line)
                yield normalize_event(obj)
            except json.JSONDecodeError:
                continue

def normalize_event(evt):
    ts = evt.get("ts")
    try:
        ts_norm = parser.isoparse(ts).isoformat() if ts else None
    except Exception:
        ts_norm = ts
    return {
        "ts": ts_norm,
        "src_ip": evt.get("src_ip"),
        "user": evt.get("user"),
        "service": evt.get("service"),
        "msg": evt.get("msg", ""),
        "raw": evt
    }""",

    "detectors.py": """import re

OWASP_MAP = {
    "Failed authentication": ["A07:2021-Identification and Authentication Failures"],
    "Injection pattern": ["A03:2021-Injection"],
    "Path traversal": ["A05:2021-Security Misconfiguration"],
    "Unauthenticated admin access": ["A01:2021-Broken Access Control"],
    "Behavioral anomaly": ["A10:2021-Behavioral Anomaly"]
}

SQLI_PATTERNS = [r"\\bUNION\\b", r"\\bSELECT\\b.*\\bFROM\\b", r"OR 1=1", r"--", r"/\\*"]
PATH_TRAV_PATTERNS = [r"\\.\\./", r"etc/passwd"]

def run_rules(evt):
    detections = []
    msg = (evt.get("msg") or "").lower()
    ip = evt.get("src_ip") or "unknown"
    user = evt.get("user") or None

    if "failed password" in msg or "authentication failure" in msg or "invalid user" in msg:
        detections.append(make_alert("Failed authentication", evt, entity=user or ip, severity="low"))

    for p in SQLI_PATTERNS:
        if re.search(p, msg, re.IGNORECASE):
            detections.append(make_alert("Injection pattern", evt, entity=ip, severity="high"))
            break
    for p in PATH_TRAV_PATTERNS:
        if re.search(p, msg, re.IGNORECASE):
            detections.append(make_alert("Path traversal", evt, entity=ip, severity="high"))
            break
    if "/admin" in msg and ("unauthenticated" in msg or "401" in msg or "403" in msg):
        detections.append(make_alert("Unauthenticated admin access", evt, entity=ip, severity="medium"))
    return detections

def make_alert(detection_name, evt, entity, severity="low"):
    return {
        "ts": evt.get("ts"),
        "detection": detection_name,
        "severity": severity,
        "entity": entity,
        "evidence": {
            "msg": evt.get("msg"),
            "src_ip": evt.get("src_ip"),
            "user": evt.get("user"),
            "service": evt.get("service")
        },
        "owasp": OWASP_MAP.get(detection_name, []),
        "recommendations": recommendations_for(detection_name)
    }

def recommendations_for(detection_name):
    if detection_name == "Failed authentication":
        return ["Monitor for password spraying; enforce MFA", "Alert if threshold exceeded", "Investigate IP"]
    if detection_name == "Injection pattern":
        return ["Isolate endpoint; apply WAF rules", "Hunt for similar payloads", "Review input sanitization"]
    if detection_name == "Path traversal":
        return ["Block IP; review file access", "Harden file permissions"]
    if detection_name == "Unauthenticated admin access":
        return ["Rate-limit; restrict admin to allowlist", "Investigate possible credential leak"]
    return ["Investigate"]""",

    "analyzer.py": """import json
from collections import defaultdict, Counter
from statistics import mean, stdev
from ingest import read_jsonl
from detectors import run_rules

def analyze_logs(input_path="sample_logs.jsonl", out_path="alerts.jsonl", z_threshold=3.0):
    events = list(read_jsonl(input_path))
    alerts = []

    for e in events:
        dets = run_rules(e)
        alerts.extend(dets)

    counts = defaultdict(int)
    for e in events:
        ip = e.get("src_ip") or "unknown"
        counts[ip] += 1

    vals = list(counts.values())
    if len(vals) >= 2:
        mu = mean(vals)
        sd = stdev(vals)
        if sd > 0:
            for ip, c in counts.items():
                z = (c - mu) / sd
                if z >= z_threshold:
                    alerts.append({
                        "ts": None,
                        "detection": "Behavioral anomaly",
                        "severity": "medium",
                        "entity": ip,
                        "evidence": {"count": c, "zscore": round(z, 2)},
                        "owasp": ["A10:2021-Behavioral Anomaly"],
                        "recommendations": ["Investigate host; consider blocking or isolating"]
                    })

    with open(out_path, "w", encoding="utf-8") as f:
        for a in alerts:
            f.write(json.dumps(a, default=str) + "\\n")

    counts_by_detection = Counter([a["detection"] for a in alerts])
    return {"alerts_count": len(alerts), "counts_by_detection": dict(counts_by_detection)}

if __name__ == "__main__":
    print(analyze_logs())""",

    "app.py": """from flask import Flask, render_template, jsonify
from analyzer import analyze_logs
import json, os

app = Flask(__name__, template_folder='templates')

ALERTS_PATH = "alerts.jsonl"
LOGS_PATH = "sample_logs.jsonl"

def read_alerts(path=ALERTS_PATH):
    alerts = []
    if not os.path.exists(path):
        return alerts
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                alerts.append(json.loads(line))
            except Exception:
                continue
    return alerts

@app.route("/")
def index():
    return render_template("dashboard.html")

@app.route("/api/alerts")
def api_alerts():
    return jsonify(read_alerts())

@app.route("/api/generate", methods=["POST"])
def api_generate():
    res = analyze_logs(input_path=LOGS_PATH, out_path=ALERTS_PATH)
    return jsonify(res)

if __name__ == "__main__":
    if not os.path.exists(ALERTS_PATH):
        analyze_logs(input_path=LOGS_PATH, out_path=ALERTS_PATH)
    app.run(debug=True, port=5000)""",

    "templates/dashboard.html": """<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ZOCK Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background:#050617; color:#e6fbff; font-family: Arial, sans-serif; margin:0; padding:20px; }
    header { display:flex; align-items:center; gap:16px; }
    h1 { color:#00d8ff; margin:0; }
    .top { display:flex; gap:20px; margin-top:16px; }
    .card { background:#0b1220; padding:14px; border-radius:8px; box-shadow:0 6px 14px rgba(0,0,0,0.6); }
    .big { font-size:28px; color:#00ffea; }
    table { width:100%; border-collapse:collapse; margin-top:12px; }
    th, td { padding:8px; border-bottom:1px solid #15202b; text-align:left; color:#dff7ff; }
    th { color:#9ef0ff; }
    button { background:#0088cc; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
    .controls { margin-left:auto; display:flex; gap:8px; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>ðŸ›¡ ZOCK</h1>
      <div style="color:#9bdfff">AI Threat Detection & Incident Response â€” Dark Dashboard</div>
    </div>
    <div class="controls">
      <button onclick="generate()">Generate Alerts</button>
      <button onclick="downloadAlerts()">Export Alerts (JSON)</button>
    </div>
  </header>

  <div class="top" style="margin-top:18px;">
    <div class="card" style="width:260px">
      <div style="font-size:14px;color:#9bdfff">Total Alerts</div>
      <div id="totalAlerts" class="big">0</div>
    </div>
    <div class="card" style="flex:1">
      <canvas id="eventsChart" height="90"></canvas>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3 style="margin:0;color:#9bdfff">Alerts</h3>
    <table id="alertsTable">
      <thead>
        <tr><th>Timestamp</th><th>Detection</th><th>Severity</th><th>Entity</th><th>OWASP</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
async function fetchAlerts(){
  const r = await fetch('/api/alerts');
  return r.json();
}

async function refresh(){
  const alerts = await fetchAlerts();
  document.getElementById('totalAlerts').innerText = alerts.length;

  const tbody = document.querySelector("#alertsTable tbody");
  tbody.innerHTML = "";
  alerts.slice().reverse().forEach(a=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${a.ts || ''}</td><td>${a.detection}</td><td>${a.severity}</td><td>${a.entity}</td><td>${(a.owasp||[]).join(', ')}</td>`;
    tbody.appendChild(tr);
  });

  const counts = {};
  alerts.forEach(a => { counts[a.detection] = (counts[a.detection]||0) + 1; });

  const labels = Object.keys(counts);
  const data = Object.values(counts);

  if(window.myChart){
    window.myChart.data.labels = labels;
    window.myChart.data.datasets[0].data = data;
    window.myChart.update();
  } else {
    const ctx = document.getElementById('eventsChart').getContext('2d');
    window.myChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Alerts by Type',
          data: data,
          backgroundColor: 'rgba(0,210,255,0.35)',
          borderColor: 'rgba(0,210,255,0.9)',
          borderWidth: 1
        }]
      },
      options: {
        responsive:true,
        plugins: { legend: { display: false } },
        scales: { y: { beginAtZero:true, ticks: { color: '#bff' } }, x: { ticks: { color:'#bff' } } }
      }
    });
  }
}

async function generate(){
  const r = await fetch('/api/generate', { method:'POST' });
  const jr = await r.json();
  alert(`Generated ${jr.alerts_count} alerts`);
  await refresh();
}

async function downloadAlerts(){
  const r = await fetch('/api/alerts');
  const alerts = await r.json();
  const blob = new Blob([JSON.stringify(alerts, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'alerts.json';
  document.body.appendChild(a); a.click(); a.remove();
}

refresh();
setInterval(refresh, 15000);
</script>
</body>
</html>"""
}

# Write files
for filename, content in files_content.items():
    filepath = os.path.join(project_dir, filename)
    if "/" in filename:  # nested template
        subdir = os.path.dirname(filepath)
        os.makedirs(subdir, exist_ok=True)
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(content)

# Zip it up
zip_path = "/mnt/data/zock_dashboard.zip"
with zipfile.ZipFile(zip_path, "w") as z:
    for root, dirs, files in os.walk(project_dir):
        for file in files:
            full_path = os.path.join(root, file)
            arcname = os.path.relpath(full_path, project_dir)
            z.write(full_path, arcname)

zip_path
